<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Young's blog]]></title>
  <subtitle><![CDATA[哀吾生之须臾，羡长江之无穷]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://youngyangyang.com/"/>
  <updated>2015-04-22T14:12:03.649Z</updated>
  <id>http://youngyangyang.com/</id>
  
  <author>
    <name><![CDATA[Young Kun]]></name>
    <email><![CDATA[297502779@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hiho1122]]></title>
    <link href="http://youngyangyang.com/2015/04/22/hiho1122/"/>
    <id>http://youngyangyang.com/2015/04/22/hiho1122/</id>
    <published>2015-04-22T14:09:22.000Z</published>
    <updated>2015-04-22T14:11:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1122_:_二分图二•二分图最大匹配之匈牙利算法">1122 : 二分图二•二分图最大匹配之匈牙利算法</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>上一回我们已经将所有有问题的相亲情况表剔除了，那么接下来要做的就是安排相亲了。<br>因为过年时间并不是很长，所以姑姑希望能够尽可能在一天安排比较多的相亲。由于一个人同一天只能和一个人相亲，所以要<strong>从当前的相亲情况表里选择尽可能多的组合，且每个人不会出现两次</strong>。<br>不知道有没有什么好办法，对于当前给定的相亲情况表，能够算出最多能同时安排多少组相亲呢？<br>同样的，我们先将给定的情况表转换成图G=(V,E)。在上一回中我们已经知道这个图可以被染成黑白两色。不妨将所有表示女性的节点记为点集A，表示男性的节点记为点集B。<br>则有A∪B=V。由问题可知所有边e的两个端点分别属于AB两个集合。则可以表示成如下的图：<br><img title="hiho34_00.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/14245073889563.png"><br>同样的，我们将所有的边分为两个集合。集合S和集合M，同样有S∪M=E。边集S表示在这一轮相亲会中将要进行的相亲，边集M表示在不在这一次进行。<br>对于任意边(u,v) ∈ S，我们称u和v为一组匹配，它们之间相互匹配。在图G，我们将边集S用实线表示，边集M用虚线表示。得到下图：<br><img title="hiho34_01.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/1424507533697.png"><br>则原问题转化为，最多能选择多少条边到集合S，使得S集合中任何两条边不相邻(即有共同的顶点)。显然的，|S|&lt;=Min{|A|, |B|}。<br>那么能不能找到一个算法，使得能够很容易计算出尽可能多的边能够放入集合S？我们不妨来看一个例子：<br><img title="hiho34_01.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/1424507533697.png"><br>对于已经匹配的点我们先不考虑，我们从未匹配的点来做。这里我们选择A集合中尚未匹配的点(A3和A4)考虑：<br>对于A3点，我们可以发现A3与B4右边相连，且都未匹配。则直接将(A3,B4)边加入集合S即可。<br><img title="hiho34_02.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/14245076439118.png"><br>对于A4点，我们发现和A4相连的B3，B4点都已经匹配了。但是再观察可以发现，如果我们将A2和B2相连，则可以将B3点空出来。那么就可以同时将(A2,B2)，(A4,B3)相连。<br>将原来的一个匹配变成了两个匹配。<br>让我们来仔细看看这一步：我们将这次变换中相关联的边标记出来，如下图所示紫色的3条边(A2,B2),(A2,B3),(A4,B3)。<br><img title="hiho34_03.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/14245076642615.png"><br>这三条边构成了一条路径，可以发现这条路径有个非常特殊的性质。<br><strong>虚线和实线相互交错，并且起点和终点都是尚未匹配的点，且属于两个不同的集合。我们称这样的路径为交错路径。 </strong><br>再进一步分析，对于任意一条交错路径，虚线的数量一定比实线的数量多1。我们将虚线和实线交换一下，就变成了下面的图：<br><img title="hiho34_04.png" style="width:20%;" src="http://media.hihocoder.com//problem_images/20150221/14245076816061.png"><br>在原来1个匹配的基础上，我们得到了2个新的匹配，S集合边的数量也增加了1。并且原来在已经匹配的点仍然是已经匹配的状态。<br>再回头看看A3点匹配时的情况：对于(A3,B4)这一条路径，同样满足了交错路径的性质。至此我们得到了一个找新匹配的有效算法：<br>选取一个未匹配的点，查找是否存在一条以它为起点的交错路径。<br>若存在，将该交错路径的边虚实交换。否则在当前的情况下，该点找不到可以匹配的点。<br>又有对于已经匹配的点，该算法并不会改变一个点的匹配状态。所以当我们对所有未匹配的点都计算过后，仍然没有交错路径，则不可能找到更多的匹配。<br>此时S集合中的边数即为最大边数，我们称为最大匹配数。<br>那么我们再一次梳理整个算法： </p>
<blockquote>
<ol>
<li>依次枚举每一个点i；</li>
<li>若点i尚未匹配，则以此点为起点查询一次交错路径。<br>最后即可得到最大匹配数。在这个基础上仍然有两个可以优化的地方：<br>1.对于点的枚举：当我们枚举了所有A中的点后，无需再枚举B中的点，就已经得到了最大匹配。<br>2.在查询交错路径的过程中，有可能出现Ai与Bj直接相连，其中Bj为已经匹配的点，且Bj之后找不到交错路径。之后又通过Ai查找到了一条交错路径{Ai,Bx,Ay,…,Az,Bj}延伸到Bj。由于之前已经计算过Bj没有交错路径，若此时再计算一次就有了额外的冗余。所以我们需要枚举每个Ai时记录B集合中的点是否已经查询过，起点不同时需要清空记录。 </li>
</ol>
</blockquote>
<p><strong>输入</strong><br>第1行：2个正整数，N,M(N表示点数 2≤N≤1,000，M表示边数1≤M≤5,000)<br>第2..M+1行：每行两个整数u,v，表示一条无向边(u,v)<br><strong>输出</strong><br>第1行：1个整数，表示最大匹配数</p>
<p><strong>样例输入</strong></p>
<blockquote>
<p>5 4<br>3 2<br>1 3<br>5 4<br>1 5</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>2</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>原题的分析已经很清楚了。。。我就不多废话了。。</p>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span> adjlist[<span class="number">1001</span>];</div><div class="line"><span class="keyword">int</span> *connected;</div><div class="line"><span class="keyword">void</span> decide(<span class="keyword">int</span> cur, <span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> & myset, <span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> *set1, <span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> *set2)</div><div class="line">{</div><div class="line">	<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span>::iterator iter = adjlist[cur].begin(); iter != adjlist[cur].end();iter++)</div><div class="line">		<span class="keyword">if</span> (myset.find(iter-&gt;first) != myset.end())</div><div class="line">		{</div><div class="line">			myset.erase(myset.find(iter-&gt;first));</div><div class="line">			set2-&gt;insert(iter-&gt;first);</div><div class="line">			decide(iter-&gt;first, myset, set2, set1);</div><div class="line">		}</div><div class="line">}</div><div class="line"><span class="keyword">int</span> findvacant(<span class="keyword">int</span> cur)</div><div class="line">{</div><div class="line">	<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span>::iterator iter = adjlist[cur].begin(); iter != adjlist[cur].end();iter++)</div><div class="line">		<span class="keyword">if</span> (connected[iter-&gt;first] == <span class="number">0</span>)</div><div class="line">		{</div><div class="line">			<span class="keyword">return</span> iter-&gt;first;</div><div class="line">		}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"><span class="keyword">bool</span> choosematch(<span class="keyword">int</span> cur,<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> &searched)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> next = findvacant(cur);</div><div class="line">	<span class="keyword">if</span> (next != <span class="number">0</span>)</div><div class="line">	{</div><div class="line">		connected[cur] = next;</div><div class="line">		connected[next] = cur;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">else</span></div><div class="line">	{</div><div class="line">		<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span>::iterator iter = adjlist[cur].begin(); iter != adjlist[cur].end();iter++)</div><div class="line">			<span class="keyword">if</span> (searched.find(iter-&gt;first) == searched.end())</div><div class="line">			{</div><div class="line">				<span class="keyword">int</span> mid = iter-&gt;first;</div><div class="line">				<span class="keyword">int</span> next = connected[mid];</div><div class="line">				searched.insert(mid);</div><div class="line">				<span class="keyword">if</span> (choosematch(next, searched))</div><div class="line">				{</div><div class="line">					connected[cur] = iter-&gt;first;</div><div class="line">					connected[iter-&gt;first] = cur;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n, m;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line">	<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> *set1=<span class="keyword">new</span> <span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span>, *set2=<span class="keyword">new</span> <span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span>;</div><div class="line">	set1-&gt;clear(); set2-&gt;clear();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> u, v;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</div><div class="line">		adjlist[u][v] = <span class="number">1</span>;</div><div class="line">		adjlist[v][u] = <span class="number">1</span>;</div><div class="line">	}</div><div class="line">	<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> myset;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">		myset.insert(i);</div><div class="line">	<span class="keyword">while</span> (myset.size()&gt;<span class="number">0</span>)</div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> cur = *(myset.begin());</div><div class="line">		myset.erase(myset.begin());</div><div class="line">		set1-&gt;insert(cur);</div><div class="line">		decide(cur, myset, set1, set2);</div><div class="line">	}</div><div class="line">	<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> * finalset;</div><div class="line">	<span class="keyword">if</span> (set1-&gt;size() &lt; set2-&gt;size())</div><div class="line">	{</div><div class="line">		finalset = set1;</div><div class="line">	}</div><div class="line">	<span class="keyword">else</span></div><div class="line">	{</div><div class="line">		finalset = set2;</div><div class="line">	}</div><div class="line">	connected = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">		connected[i] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span>::iterator iter = finalset-&gt;begin(); iter != finalset-&gt;end(); iter++)</div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> cur = *iter;</div><div class="line">		<span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> searched;</div><div class="line">		searched.clear();</div><div class="line">		choosematch(cur,searched);</div><div class="line">	}</div><div class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</div><div class="line">		<span class="keyword">if</span> (connected[i] != <span class="number">0</span>)</div><div class="line">		{</div><div class="line">			ans++;</div><div class="line">		}</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; (ans / <span class="number">2</span>) &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1122_:_二分图二•二分图最大匹配之匈牙利算法">1122 : 二分图二•二分图最大匹配之匈牙利算法</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><b]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1148]]></title>
    <link href="http://youngyangyang.com/2015/04/21/hiho1148/"/>
    <id>http://youngyangyang.com/2015/04/21/hiho1148/</id>
    <published>2015-04-21T14:37:09.000Z</published>
    <updated>2015-04-21T14:39:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="hiho1148：骨牌覆盖问题·二">hiho1148：骨牌覆盖问题·二</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>上一周我们研究了2xN的骨牌问题，这一周我们不妨加大一下难度，研究一下3xN的骨牌问题？<br>所以我们的题目是：对于3xN的棋盘，使用1x2的骨牌去覆盖一共有多少种不同的覆盖方法呢？<br>首先我们可以肯定，奇数长度一定是没有办法覆盖的；对于偶数长度，比如2，4，我们有下面几种覆盖方式：<br><img src="http://media.hihocoder.com/problem_images/20150418/1429340404434.png" style="float:none;" title="week42_1.PNG"><br><strong>输入</strong><br>第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000<br><strong>输出</strong><br>第1行：1个整数，表示覆盖方案数 MOD 12357</p>
<p><strong>样例输入</strong></p>
<blockquote>
<p>62247088</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>4037</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>个人感觉本题的状态转移矩阵的推导并不十分清晰，我就自己思考了一下，然后解释一下。<br>首先是考虑第i列的状况，说明第i-1列已经填满，且第i+1列还没有任何骨牌覆盖。那么我们可以用0~7这8个数字的二进制来表示第i列被覆盖的骨牌位置。<br>我们依次分析状态转移，</p>
<blockquote>
<p>0-&gt;7：这没什么好讲的，横着放三块<br>1-&gt;6: 横着放两块。我一直很好奇，为什么不能1-&gt;0?但仔细想想，如果是1-&gt;0的话，那么就是说在第i列要放竖着的一块骨牌，这样第i+1列才是0。但这个状态不就是7了么？<br>也就是说其实我们这里是1-&gt;6而不是1-&gt;6和0的原因就是不要重复计算状态。</p>
</blockquote>
<p>剩下的也一样推理，可以得到转移矩阵。<br>其实按照矩阵的乘法，我们可以先把方阵都乘好，最后再乘以列向量，而因为列向量除了最后一位为1其余都是0，所以最终结果应该是方阵的最右下角的值。</p>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">void</span> oct2bi(<span class="keyword">int</span> n, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &bivec)</div><div class="line">{</div><div class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>)</div><div class="line">	{</div><div class="line">		bivec.push_back(n % <span class="number">2</span>);</div><div class="line">		n /= <span class="number">2</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">	<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> bivec;</div><div class="line">	oct2bi(n, bivec);</div><div class="line">	<span class="keyword">int</span> mi[<span class="number">100</span>][<span class="number">8</span>][<span class="number">8</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">			mi[<span class="number">0</span>][i][j] = <span class="number">0</span>;</div><div class="line">	mi[<span class="number">0</span>][<span class="number">0</span>][<span class="number">7</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">1</span>][<span class="number">6</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">2</span>][<span class="number">5</span>] = <span class="number">1</span>;</div><div class="line">	mi[<span class="number">0</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">3</span>][<span class="number">7</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">	mi[<span class="number">0</span>][<span class="number">5</span>][<span class="number">2</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">6</span>][<span class="number">7</span>] = <span class="number">1</span>;</div><div class="line">	mi[<span class="number">0</span>][<span class="number">7</span>][<span class="number">0</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">	{</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</div><div class="line">				mi[i][j][k] = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</div><div class="line">			{</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">8</span>; t++)</div><div class="line">					mi[i][j][k] =(mi[i][j][k]+mi[i - <span class="number">1</span>][j][t] * mi[i - <span class="number">1</span>][t][k])%<span class="number">12357</span>;</div><div class="line">			}</div><div class="line">	}</div><div class="line">	<span class="keyword">int</span> temp[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>;j++)</div><div class="line">			<span class="keyword">if</span> (i == j)</div><div class="line">			{</div><div class="line">				temp[i][j] = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">			<span class="keyword">else</span>{</div><div class="line">				temp[i][j] = <span class="number">0</span>;</div><div class="line">			}</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = bivec.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">		<span class="keyword">if</span> (bivec[i] == <span class="number">1</span>)</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> tempans[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</div><div class="line">					tempans[j][k] = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</div><div class="line">				{</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">8</span>; t++)</div><div class="line">						tempans[j][k] =(tempans[j][k]+ temp[j][t] * mi[i][t][k])%<span class="number">12357</span>;</div><div class="line">				}</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</div><div class="line">					temp[j][k] = tempans[j][k];</div><div class="line">		}</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; temp[<span class="number">7</span>][<span class="number">7</span>] &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="hiho1148：骨牌覆盖问题·二">hiho1148：骨牌覆盖问题·二</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>上一周我们研究了2xN的骨牌]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning from the best]]></title>
    <link href="http://youngyangyang.com/2015/04/21/learning-from-the-best/"/>
    <id>http://youngyangyang.com/2015/04/21/learning-from-the-best/</id>
    <published>2015-04-21T06:33:29.000Z</published>
    <updated>2015-04-21T06:48:31.000Z</updated>
    <content type="html"><![CDATA[<p>这是我自行翻译的一篇Kaggle的博文，作为自己博客里有关数据挖掘和机器学习方面博文的开端。</p>
<p>由于才疏学浅，英语知识还不够过硬，所以一些英文并不是翻译地很好。</p>
<p>文章名为<a href="http://blog.kaggle.com/2014/08/01/learning-from-the-best/" target="_blank" rel="external">learnig form the best | no free lunch</a></p>
<p>特邀投稿者David Kofoed Wind是丹麦技术大学认知领域的博士研究生：</p>
<p>作为我有关竞争机器学习的硕士论文的一部分，我和一系列的Kaggle大师们以试着去理解他们在各项竞赛里持续表现优异的原因。<br>我所得到的结果是一系列广为人知的策略，和一些相对不显然的窍门。在这篇博客中，我挑选了他们回答我问题的一些答案，试图概括出能使我们在Kaggle中表现地优秀的策略。<br>就好像这篇博客的名字所透露的那样，天下没有免费的午餐，阅读这篇博客并不能让你一夜之间成为一名Kaggle大师。<br>然而，遵循下面所列出来的步骤会尽可能地帮助你在积分排行榜上获得体面的成绩。我将这些答案分成了一系列的宽泛的主题，最后还附上了一系列各种各样的建议。</p>
<h2 id="特征工程经常是最重要的部分"><strong>特征工程经常是最重要的部分</strong></h2>
<p>随着针对数据分析的免费的工具包和库函数越来越多，每个人都有机会在一场比赛中尝试高级的统计模型。<br>这导致了，给你最货真价实（bang-for-the-buck）的感觉的并不是你使用的统计学模型，而是你在模型里运用到的特征。<br>通过特征工程，我的意思是使用领域内的特定知识或者自动的方法来在数据集中产生、提取、删除或者修改特征。</p>
<blockquote>
<p>特征工程是大多数Kaggle比赛中最重要的部分，而这是最容易去学如何去做的。——（Tim Salimans）</p>
<p>你使用的特征比其他东西更多地影响到了结果。据我了解，没有任何一个算法可以独自地补充通过正确地特征工程可以得到的信息增益。（Luca Massaron）</p>
<p>特征工程绝对是Kaggle竞赛中最重要的方面之一，而且它是最需要花时间的部分。总是有一些可以大幅度地提高你的表现的隐式特征。<br>如果你想在积分排行榜上获得好的名次，你需要去发现他们。如果你在这个方面搞砸了，那你几乎很难赢了；而总是有一些人可以发现所有的秘诀。<br>然而，也存在其他重要的部分，比如你如何认知这个问题（formulate the problem）。你可能会用一个回归模型，或是一个分类模型，或者甚至是两者的结合，或者是一些排名需要的。<br>这些，以及特征工程，对在那些比赛里获得一个号的成绩至关重要。同样也有一些比赛可能并不需要（手动的）特征工程；比如在一些图像处理比赛里。<br>深度学习算法的最新进展可以帮你做那些。（Josef Feigl）</p>
</blockquote>
<p>相反，有时候获胜的解决方案是那些采用了一些非直观的方案以及简单的采用了黑盒方法。一个例子就是太阳能比赛，<br>获胜的前三甲几乎没有使用任何特征工程（及时这似乎是这个比赛一种直觉的方法），而仅仅是讲整个数据集结合到一个大的数据表格之中，<br>并使用一个复杂的黑盒模型（比如一个梯度boosting回归的综合体）。</p>
<h2 id="简单的模型会让你前进得更多"><strong>简单的模型会让你前进得更多</strong></h2>
<p>当一场比赛结束之后，我们仔细去看不同的解决方案的描述。我们会发现有一个令人惊讶的数目的简单的解决方案获得了很好的结果。<br>更令人（最初）感到惊讶的是，最简单的方法经常被一些顶尖的选手反复提及。</p>
<blockquote>
<p>我认为初学者经常有时候都没有开始了解数据就把算法“扔”在了问题上。我同样认为有时候初学者会过早地去做太复杂的事情了。<br>有一个观点认为如果你可以发明复杂的事情的话，那会显得你更机智。我“尝试”去遵循爱因斯坦的名言：“任何一个机智的傻逼可以把事情做得繁冗复杂。<br>但是这需要一点天才和一些努力去将事情推向另一个方向。”（Steve Donoho）</p>
<p>我前几次提交基本上就是几种极度简单的基础提交方案的-好像“猜测均值”或者“猜测根据x变量分隔开的均值”。这些可以用非常简单的模型非常方便地建立。<br>你会感到惊讶，你有时候用很简单的模型就能得到与复杂模型很接近的分数。（Steve Donoho）</p>
<p>如果你能熟练运用它们的话，简单的模型会让你走的更远。但一般来说，你不可能仅仅通过简单的模型就能获得一场比赛的胜利。<br>简单模型可以很便捷地去训练和理解，而且它们比复杂的黑盒更让你有洞察力。它们也更容易被修改和调整以适应不同的状况。<br>它们也同样强制你在数据本身（特征工程，数据清理，缺失数据估计）上下功夫。另一方面，简单会受制于高的变差，<br>于是它们偏向于不会获得一个你的未知函数的复杂映射。（On the other hand,being simple,they suffer from high bias,<br>so they likely cannot catch a complex mapping of your unknown function.）（Luca Massaron）</p>
</blockquote>
<h2 id="过拟合排行榜是一个现实问题"><strong>过拟合排行榜是一个现实问题</strong></h2>
<p>在一个比赛中，你有机会向排行榜提交。通过向排行榜进行提交解决方案，你会得到测试集的公共部分对你的模型的评价。<br>很显然获得排行榜的评估会给你额外的信息和数据，但是这也会带来过拟合排行榜分数的可能性。<br>两个较近的过拟合排行榜的比赛例子是大数据结合和StumbleUpon Evergreen Classification Challenge。<br>在下面的表格里，StumbleUpon比赛排名前十的公开排行榜和他们各自在私人排行榜上的名次排名。</p>
<p>| 用户名        | 公开榜   |  私人榜  |</p>
<p>| ————   | ——-:  | :——:  |</p>
<p>| Jared Huling     | 1 |   283     |</p>
<p>| Yevgeniy        |   2   |   7   |</p>
<p>| Attila Balogh        |    3    |  231  |</p>
<p>| Abhishek        |    4    |  6  |</p>
<p>| Issam Laradji        |    5    |  9  |</p>
<p>| Ankush Shah        |    6    |  11  |</p>
<p>| Grothendieck        |    7    |  50  |</p>
<p>| Thakur Raj Anand        |    8    |  247  |</p>
<p>| Manuel Dias        |    9    |  316  |</p>
<p>| Juventino        |    10    |  27  |</p>
<p>这个挑战赛有7395个样本，而且它被广泛地审视过，数据有相当多的噪声。在大数据结合竞赛里，人们的任务是预测多个小时后的股票数值，<br>这一般来说是极度困难的。在排行榜上极端地掉队大多数是因为预测股票的纯粹的困难，以及过拟合。</p>
<blockquote>
<p>排行榜肯定存在着各种各样的信息。尤其当排行榜比训练集有更多时间跨度的数据的时候（比如遗产卫生奖）。你可以用这些信息去建模一些选择和超参数调谐。（Tim Salimans）</p>
<p>公共排行榜也能提供一些帮助，[……]但是需要去注意不要去过拟合，尤其是在一些小数据集上。和我聊过的一些高手选择他们最终的提交是基于他们排行榜的成绩和他们CV成绩的加权<br>（权值是根据数据集的大小）。Kaggle使得过拟合的危险更加具有可能。没有什么比公共榜的一个好排名掉到私人榜的一个坏排名更能教育一个人需要特别特别地注意不要过拟合的了。（Steve Donoho）</p>
<p>过拟合对于排行榜来说总是一个主要问题。避免它的最好方法是完全忽略排行榜的成绩并且只相信你的交叉验证的结果。最主要的问题是你的交叉验证必须是正确的，<br>而且你的CV成绩和排行榜成绩要存在明显的相关性（例如：你CV成绩的提升会引起你排行榜成绩的提升）。如果对于某个给定竞赛发生了这种情况，那么这会很简单去避免过拟合。<br>这一般对测试集足够大的情况下非常奏效。如果测试集很小而且如果没有很明显的相关性，那么这就很难仅仅去相信你的CV成绩。<br>这可能发生在数据集合是从训练集合以外的分布上选取出来的情况下。（Josef Feigl）</p>
</blockquote>
<h2 id="集成是必胜的策略"><strong>集成是必胜的策略</strong></h2>
<p>如果去看过去竞赛的获胜者，大多数获得奖金的模型是大多数模型的集成，这已经是一个普遍的趋势了。集成的强大能力同样可以被数学上证明可行。</p>
<blockquote>
<p>无论你单独的模型多正确，多么被调节好，你都可以通过集成的方法来提高准确率。集成的方法在个别的模型很少关联的情况下效果最好。<br>将多数表现平平的模型放入一个搅拌机里可能会变得事与愿违。将一些构建地非常好的模型结合在一起似乎会表现地更好。说到这些，有可能会过调节某个模型从而危害到整体的效果。<br>那么棘手的部分就是发现正确的平衡点。（Anil Thomas）</p>
<p>我是一个集成方法的信徒。它们的确会提高准确率。但是我一般会在最后一步才做这个事情。我一般会榨取除了创造派生变量之外的一切和使用单独算法。<br>知道我感觉到我已经把前面所有的东西都做尽了，我才会尝试集成。（Steve Donoho）</p>
<p>集成法是一个无脑行为。只要它能够提升你的成绩你就需要在每一场比赛里采用它。然而，对于我来说它一般来说是我在一场比赛中最后做的事情，而且我一般不在它上面花太久的时间。（Josef Feigl）</p>
</blockquote>
<h2 id="预测正确的事情是很重要的"><strong>预测正确的事情是很重要的</strong></h2>
<p>一个任务有时候是至关重要的，有时候却不是。这就是预测正确的事情。在预测正确的事情很重要的时候它就显得至关重要（这不是废话么……），但是它不总是实践中一个简单的事情。</p>
<blockquote>
<p>下一步是去问：“我到底应该预测什么？”。这重要的一部经常被很多人所忽略，他们只是将原始的变量代入到他们最喜欢的算法中去，以求能得到最棒的结果。<br>但是有时候你想要去得到一个衍生的相关变量。我会用GE航班客户作为一个例子：你不会想要去预测飞机会降落的准确时间；你想要去预测航班飞行的总时长；<br>也许实现它最好的方法是采用航班实际飞行的时长和它原始预估的时长的比值乘以原始估计的次数。（Steve Donoho）</p>
</blockquote>
<p>有两种方法可以处理预测正确的事情的问题：第一种方法是引用Steve Donoho在上面有关于预测正确的衍生变量的话；第二个是采用正确的损失函数来训练统计模型。</p>
<blockquote>
<p>仅仅是将RMSE变为MAE会大大地改变一个简单的模型（比如线性回归）的系数。优化成正确的度量方法真的可以让你在排行榜上拍的更高，尤其是在涉及变量选择的情况下。（Luca Massaron）</p>
<p>一般来说优化正确的度量方式是很合理的（尤其在你个人的CV成绩里）。[……]然而，你并不是非做不可。例如一年之前，我赢得了事件推荐动力挑战赛，而度量方法是MAP。<br>我从来没用过这种度量方法，而且评估我所有模型的方法都是log损失函数。它都很有效。（Josef Feigl）</p>
</blockquote>
<p>我们用一个例子来展示为什么使用一个错误的损失函数会将问题增高，看下面这个简单的样例：说出你想要去拟合最简单的可能的回归模型，也就是说只是一个截取一个数据的a：<br>X={0.1,0.2,0.4,0.2,0.2,0.1,0.3,0.2,0.3,0.1,100}</p>
<p>如果我们用$$a<em>{MSE}$$ 代表a最小化均方误差，且让$$a</em>{MAE}$$代表a最小化绝对值误差均值，我们可以得到下面的结果：</p>
<p>$$a_{MSE} =9.2818$$</p>
<p>$$a_{MAE}=0.2000$$</p>
<p>如果我们使用两个a的估计来计算MSE和MAE，我们可以得到以下的结果：</p>
<p>$$\dfrac{1}{11}\sum\limits<em>{i}|x</em>{i}-a_{MAE}|=9.5909$$</p>
<p>$$\dfrac{1}{11}\sum\limits<em>{i}|x</em>{i}-a_{MSE}|=16.4942$$</p>
<p>$$\dfrac{1}{11}\sum\limits<em>{i}|x</em>{i}-a_{MAE}|^2=905.4660$$</p>
<p>$$\dfrac{1}{11}\sum\limits<em>{i}|x</em>{i}-a_{MSE}|^2=822.9869$$</p>
<p>就像预期的那样，我们可以看到对于每个损失函数（MAE和MSE），用来的拟合使损失函数最小的变量可以获得一个更低的误差。这点应该不会让人感到惊讶，<br>但是当损失函数和统计模型变得非常复杂的时候。一个方法是否最优化并不是一定那么重要了。</p>
<h2 id="附加的以及个人建议"><strong>附加的以及个人建议</strong></h2>
<p>从我参加过的Kaggle竞赛中获得的最重要的事情是立刻行动，并尽快在排行榜上占领有利位置。完成一个完整的流水线将数据读入并输出一个格式正确的提交需要很大的功夫，</p>
<blockquote>
<p>这往往被人低估。从排行榜上得到一个简单的评估是一个非常好的开端，如果你不能复制这个评估成绩，那么这应该是你尝试更高级的方法前的第一步。</p>
<p>我最令人惊讶的经历是发现Friedman梯度提升机持续地有出色的结果。这结果并不是从字面上能看出来的，它在实践中表现出其闪光点。（Gabor Takacs）</p>
</blockquote>
<p>作为Kaggle的新手，一开始尝试最炫的模型是非常诱人的。而理想地来说，我们应该将很多的时间花在仔细把玩数据上。尝试一些简单的模型，将不同的变量绘制在一起。<br>这都是在Kaggle中获得好成绩的一个非常重要方面。一开始就选用一个复杂的模型会降低你的速率，因为训练和测试时间会变得非常漫长，这同样意味着你并不能尝试各种不同的东西。<br>即使我曾经个人参加过一些Kaggle的竞赛，将足够的时间放在处理数据上依旧是我最专注做的事。</p>
<blockquote>
<p>你在你的工具箱中拥有的工具越多，你为解决一个问题所做的准备就越完备。如果我在我的工具箱里只有一把锤子而你工具箱里满满的都是工具，那么你比我更有可能建造一个更好的房子。所以人们都在他们各自的工具箱里放了好多工具，但是他们不知道“何时”用“何种”工具。我想，知道这些更为重要。有人在他们的工具箱里有很多工具，但是他们只是随机地在工具箱里拿一个工具，却不问为什么：“哪款工具更适合这个问题呢？”（Steve Donoho）</p>
</blockquote>
<p>好好利用Kaggle论坛是许多顶尖的选手提出的建议。在比赛期间，很多参赛者会写出高亮数据集中特征和趣事的问题，有的参赛者甚至会在论坛公布获得很高分数的代码。<br>在比赛结束，一般来说，获胜者都会分享他们的解决方案。仔细阅读那些东西，它们一定会在你下次尝试的时候给你很好的启发。</p>
<blockquote>
<p>给新来者最好的建议就是阅读论坛。你会在那发现很多很好的建议，和一些能帮助你动手的代码。而且，并不需要在比赛开始的时候就花费很多的时间在优化模型参数上。<br>在比赛末尾的时候，有的是时间留给那些工作。（Josef Feigl）</p>
<p>在每个比赛中我都从获胜者身上学到了一些。一个比赛并不是因为一次洞察就能赢下来的，而是通过多次仔细的尝试才慢慢靠近好的模型的。<br>所有东西都在发挥它的作用，所以这里并没有什么秘密的方法。仅仅是将几节课上学到的知识运用在这里而已。我认为新的Kaggle选手会从阅读论坛和过去的比赛获胜者的文章中受益匪浅。<br>Kaggle获胜者不会在建议上弄虚作假！（Lucas S）</p>
</blockquote>
<p></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我自行翻译的一篇Kaggle的博文，作为自己博客里有关数据挖掘和机器学习方面博文的开端。</p>
<p>由于才疏学浅，英语知识还不够过硬，所以一些英文并不是翻译地很好。</p>
<p>文章名为<a href="http://blog.kaggle.com/2014/08]]>
    </summary>
    
      <category term="翻译" scheme="http://youngyangyang.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="机器学习" scheme="http://youngyangyang.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="http://youngyangyang.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="DataMining&amp;MachineLearning" scheme="http://youngyangyang.com/categories/DataMining-MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微软编程之美挑战赛2015资格赛第二题]]></title>
    <link href="http://youngyangyang.com/2015/04/21/hihoartpro2/"/>
    <id>http://youngyangyang.com/2015/04/21/hihoartpro2/</id>
    <published>2015-04-21T06:33:11.000Z</published>
    <updated>2015-04-21T06:38:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="微软编程之美2015资格赛：回文字符序列">微软编程之美2015资格赛：回文字符序列</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>给定字符串，求它的回文子序列个数。回文子序列反转字符顺序后仍然与原序列相同。例如字符串aba中，回文子序列为”a”, “a”, “aa”, “b”, “aba”，共5个。内容相同位置不同的子序列算不同的子序列。</p>
<p><strong>输入</strong><br>第一行一个整数T，表示数据组数。之后是T组数据，每组数据为一行字符串。</p>
<p><strong>输出</strong><br>对于每组数据输出一行，格式为”Case #X: Y”，X代表数据编号（从1开始），Y为答案。答案对100007取模。</p>
<p><strong>数据范围</strong><br>1 ≤ T ≤ 30</p>
<p>小数据</p>
<p>字符串长度 ≤ 25</p>
<p>大数据</p>
<p>字符串长度 ≤ 1000</p>
<p><strong>样例输入</strong></p>
<blockquote>
<p>5<br>aba<br>abcbaddabcba<br>12111112351121<br>ccccccc<br>fdadfa</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>Case #1: 5<br>Case #2: 277<br>Case #3: 1333<br>Case #4: 127<br>Case #5: 17</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>本题乍看很难，的确很难啊。多亏了某晕哥的某acm学长，学长为什么都这么吊。<br>这种题目肯定只能动态规划了，窝开始也是这么想的，但是不太知道怎么写递推公式。还是学长吊。<br>假设f(i,j)表示从第i个字符开始到第j个字符结束的字符串所有的回文子串的个数。那么结果就直接输出f(1,n)就行了。<br>下面是重要的递推公式：</p>
<blockquote>
<p>$$f(i,j)=f(i,j-1)+1+\sum_{k=i}^{j-1} f(k+1,j-1)$$  if string[k]==string[j]<br>看懂什么意思么？看不懂吧。看不懂就对了，我用markdown写这个公式都花了半天，你这么快就懂了，那我面子往哪搁。<br>从i开始到j结束的回文子串有两种情况<br>第一种，包含第j个字符<br>第二种，不包含第j个字符<br>那么不包含第j个字符不就是f(i,j-1)了么<br>包含第j个字符根据到底是跟谁对称的，又分n多种情况，但是，我们是可以枚举的。<br>假设，第k个字符和第j个字符对称，那么以k开头，j结尾的回文子串(包含两个字符)有多少个呢，有f(k+1,j-1)个。<br>把它们统统加起来——庞统<br>最后要+1，为什么不是+10086呢，因为第j个字符本身也是个回文子串啊。<br>好了剩下的就是码代码了。</p>
</blockquote>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> mycount[<span class="number">1002</span>][<span class="number">1002</span>];</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; t;</div><div class="line">	<span class="built_in">string</span> str;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; t; n++)</div><div class="line">	{</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; str;</div><div class="line">		<span class="keyword">int</span> len = str.size();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++)</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1002</span>; j++)</div><div class="line">				mycount[i][j] = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">			mycount[i][i] = <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">		{</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</div><div class="line">			{</div><div class="line">				mycount[i][j] = mycount[i][j - <span class="number">1</span>];</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++)</div><div class="line">					<span class="keyword">if</span> (str[k] == str[j])</div><div class="line">						mycount[i][j] += (mycount[k + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>) % <span class="number">100007</span>;</div><div class="line">				mycount[i][j] = (mycount[i][j] + <span class="number">1</span>) % <span class="number">100007</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;(n+<span class="number">1</span>)&lt;&lt;<span class="string">": "</span> &lt;&lt; mycount[<span class="number">0</span>][len - <span class="number">1</span>] &lt;&lt; endl;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="微软编程之美2015资格赛：回文字符序列">微软编程之美2015资格赛：回文字符序列</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>给定字符串，求它]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程之美挑战赛2015资格赛第一题]]></title>
    <link href="http://youngyangyang.com/2015/04/21/hihoartpro1/"/>
    <id>http://youngyangyang.com/2015/04/21/hihoartpro1/</id>
    <published>2015-04-21T06:32:59.000Z</published>
    <updated>2015-04-21T06:37:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="微软编程之美2015资格赛：2月29日">微软编程之美2015资格赛：2月29日</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>给定两个日期，计算这两个日期之间有多少个2月29日（包括起始日期）。</p>
<p>只有闰年有2月29日，满足以下一个条件的年份为闰年：</p>
<ol>
<li><p>年份能被4整除但不能被100整除</p>
</li>
<li><p>年份能被400整除</p>
</li>
</ol>
<p><strong>输入</strong><br>第一行为一个整数T，表示数据组数。</p>
<p>之后每组数据包含两行。每一行格式为”month day, year”，表示一个日期。month为{“January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November” , “December”}中的一个字符串。day与year为两个数字。</p>
<p>数据保证给定的日期合法且第一个日期早于或等于第二个日期。</p>
<p><strong>输出</strong><br>对于每组数据输出一行，形如”Case #X: Y”。X为数据组数，从1开始，Y为答案。</p>
<p><strong>数据范围</strong><br>1 ≤ T ≤ 550</p>
<p>小数据：</p>
<p>2000 ≤ year ≤ 3000</p>
<p>大数据：</p>
<p>2000 ≤ year ≤ 2×109</p>
<p><strong>样例输入</strong></p>
<blockquote>
<p>4<br>January 12, 2012<br>March 19, 2012<br>August 12, 2899<br>August 12, 2901<br>August 12, 2000<br>August 12, 2005<br>February 29, 2004<br>February 29, 2012</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>Case #1: 1<br>Case #2: 0<br>Case #3: 1<br>Case #4: 3</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>本题乍看不难，所以我就被迷惑了开始做了。事实上确实不难。<br>我的思路很简单，就是找到起始点开始向后（包括当天）最近的一个2月29日，把年份保存下来。<br>再找到结束点向前（包括当天）最近的一个2月29日，把年份保存下来。<br>这样就不用考虑月和日了，只要考虑两个闰年之间还有多少个闰年。<br>对于小数据最简单的方法就是暴力搜索，枚举之间每四年（闰年最多每四年一次）的年份，然后判断是否为闰年。<br>对于大数据来说，就可以考虑小学数学里面有关重复了怎么加怎么减的那个东西（忘了叫什么名字了）。<br>就是把被四整除的年份找出来year4，再把被100整除的找出来year100，最后找出被400整除的。<br>结果就是year4-year100+year400。<br>有一个小trick：</p>
<blockquote>
<p>本来想用enum来记录一年十二个月份的英文，后来发现不太好用，就改成了switch，最后决定还是用数组。没错，数组可简单了，推荐在数组首位放一个空字符串，这样省得麻烦<br>以下是我的代码</p>
</blockquote>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> months[<span class="number">13</span>] = { <span class="string">""</span>, <span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>, <span class="string">"August"</span>, <span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span> };</div><div class="line"><span class="keyword">int</span> decideMonth(<span class="keyword">const</span> <span class="built_in">string</span> & s1)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (months[ans] != s1)</div><div class="line">		ans++;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">}</div><div class="line"><span class="keyword">bool</span> leapYear(<span class="keyword">int</span> year)</div><div class="line">{</div><div class="line">	<span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> && (year % <span class="number">100</span> != <span class="number">0</span>))</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> transdate2int(<span class="built_in">string</span> datestr)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> date = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (datestr[index] != <span class="string">','</span>)</div><div class="line">	{</div><div class="line">		date = date * <span class="number">10</span> + (datestr[index] - <span class="string">'0'</span>);</div><div class="line">		index++;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> date;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; t;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</div><div class="line">	{</div><div class="line">		<span class="built_in">string</span> monthstr, datestr;</div><div class="line">		<span class="keyword">int</span> yearbeg;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; monthstr &gt;&gt; datestr&gt;&gt;yearbeg;</div><div class="line">		<span class="keyword">int</span> month = decideMonth(monthstr);</div><div class="line">		<span class="keyword">int</span> date = transdate2int(datestr);</div><div class="line">		<span class="keyword">if</span> (leapYear(yearbeg) && (month == <span class="number">1</span> || (month == <span class="number">2</span> && date &lt;= <span class="number">29</span>)))</div><div class="line">		{</div><div class="line">			<span class="comment">//如果本身就是闰年，而且日期早于2月29日，那么起始年份就是本年</span></div><div class="line">			;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			<span class="comment">//否则往后推</span></div><div class="line">			yearbeg++;</div><div class="line">			<span class="keyword">while</span> (!leapYear(yearbeg))</div><div class="line">				yearbeg++;</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> yearend;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; monthstr &gt;&gt; datestr &gt;&gt; yearend;</div><div class="line">		month = decideMonth(monthstr);</div><div class="line">		date = transdate2int(datestr);</div><div class="line">		<span class="keyword">if</span> (leapYear(yearend) && (month &gt;= <span class="number">3</span> || (month == <span class="number">2</span> && date == <span class="number">29</span>)))</div><div class="line">		{</div><div class="line">			<span class="comment">//如果本身是闰年，而且，日期在2月29日之后，那么截止年份就是yearend</span></div><div class="line">			;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			yearend--;</div><div class="line">			<span class="keyword">while</span> (!leapYear(yearend))</div><div class="line">				yearend--;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (yearend &lt; yearbeg)</div><div class="line">		{</div><div class="line">			<span class="comment">//肯定是没有的啦</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;(i+<span class="number">1</span>)&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> ans = (yearend - yearbeg) / <span class="number">4</span> + <span class="number">1</span>;</div><div class="line">			<span class="keyword">int</span> year100beg = yearbeg, year400beg = yearbeg;</div><div class="line">			<span class="keyword">int</span> year100end = yearend, year400end = yearend;</div><div class="line">			<span class="keyword">while</span> (year100beg % <span class="number">100</span> != <span class="number">0</span>)</div><div class="line">				year100beg +=<span class="number">4</span>;</div><div class="line">			<span class="keyword">while</span> (year400beg % <span class="number">400</span> != <span class="number">0</span>)</div><div class="line">				year400beg += <span class="number">4</span>;</div><div class="line">			<span class="keyword">while</span> (year100end % <span class="number">100</span> != <span class="number">0</span>)</div><div class="line">				year100end -= <span class="number">4</span>;</div><div class="line">			<span class="keyword">while</span> (year400end % <span class="number">400</span> != <span class="number">0</span>)</div><div class="line">				year400end -= <span class="number">4</span>;</div><div class="line">			<span class="keyword">int</span> ans100 = <span class="number">0</span>, ans400 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">if</span> (year100beg &lt;= year100end)</div><div class="line">			{</div><div class="line">				ans100 = (year100end - year100beg) / <span class="number">100</span> + <span class="number">1</span>;</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (year400beg &lt;= year400end)</div><div class="line">			{</div><div class="line">				ans400 = (year400end - year400beg) / <span class="number">400</span> + <span class="number">1</span>;</div><div class="line">			}</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span> &lt;&lt; (ans-ans100+ans400)&lt;&lt;endl;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="微软编程之美2015资格赛：2月29日">微软编程之美2015资格赛：2月29日</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>给定两个日期，计算这]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1121]]></title>
    <link href="http://youngyangyang.com/2015/04/15/hiho1121/"/>
    <id>http://youngyangyang.com/2015/04/15/hiho1121/</id>
    <published>2015-04-15T06:03:03.000Z</published>
    <updated>2015-04-15T06:04:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1121：二分图一•二分图判定">题目1121：二分图一•二分图判定</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>大家好，我是小Hi和小Ho的小伙伴Nettle，从这个星期开始由我来完成我们的Weekly。<br>新年回家，又到了一年一度大龄剩男剩女的相亲时间。Nettle去姑姑家玩的时候看到了一张姑姑写的相亲情况表，上面都是姑姑介绍相亲的剩男剩女们。每行有2个名字，表示这两个人有一场相亲。由于姑姑年龄比较大了记性不是太好，加上相亲的人很多，所以姑姑一时也想不起来其中有些人的性别。因此她拜托我检查一下相亲表里面有没有错误的记录，即是否把两个同性安排了相亲。<br>OK，让我们愉快的暴力搜索吧！</p>
<p>才怪咧。//题目真傲娇</p>
<p>对于拿到的相亲情况表，我们不妨将其转化成一个图。将每一个人作为一个点(编号1..N)，若两个人之间有一场相亲，则在对应的点之间连接一条无向边。(如下图)<br><img src="http://media.hihocoder.com/problem_images/20150214/14238947716934.png" style="width:25%;margin-bottom:10px;" title="img1.png"><br>因为相亲总是在男女之间进行的，所以每一条边的两边对应的人总是不同性别。假设表示男性的节点染成白色，女性的节点染色黑色。对于得到的无向图来说，即每一条边的两端一定是一白一黑。如果存在一条边两端同为白色或者黑色，则表示这一条边所表示的记录有误。</p>
<p>由于我们并不知道每个人的性别，我们的问题就转化为判定是否存在一个合理的染色方案，使得我们所建立的无向图满足每一条边两端的顶点颜色都不相同。</p>
<p>那么，我们不妨将所有的点初始为未染色的状态。随机选择一个点，将其染成白色。再以它为起点，将所有相邻的点染成黑色。再以这些黑色的点为起点，将所有与其相邻未染色的点染成白色。不断重复直到整个图都染色完成。(如下图)<br><img src="http://media.hihocoder.com/problem_images/20150214/img2.png" style="width:100%;margin-bottom:10px;" title="img2.png"><br>在染色的过程中，我们应该怎样发现错误的记录呢？相信你一定发现了吧。对于一个已经染色的点，如果存在一个与它相邻的已染色点和它的颜色相同，那么就一定存在一条错误的记录。(如上图的4，5节点)</p>
<p>到此我们就得到了整个图的算法：</p>
<p>1.选取一个未染色的点u进行染色<br>2.遍历u的相邻节点v：若v未染色，则染色成与u不同的颜色，并对v重复第2步；若v已经染色，如果 u和v颜色相同，判定不可行退出遍历。<br>3.若所有节点均已染色，则判定可行。</p>
<p>接下来就动手写写吧！</p>
<p><strong>输入</strong><br>第1行：1个正整数T(1≤T≤10)</p>
<p>接下来T组数据，每组数据按照以下格式给出：</p>
<p>第1行：2个正整数N,M(1≤N≤10,000，1≤M≤40,000)</p>
<p>第2..M+1行：每行两个整数u,v表示u和v之间有一条边</p>
<p><strong>输出</strong><br>第1..T行：第i行表示第i组数据是否有误。如果是正确的数据输出”Correct”，否则输出”Wrong”<br><strong>样例输入</strong></p>
<blockquote>
<p>2<br>5 5<br>1 2<br>1 3<br>3 4<br>5 2<br>1 5<br>5 5<br>1 2<br>1 3<br>3 4<br>5 2<br>3 5</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>Wrong<br>Correct</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>这道题以前AC过，不过以前用的是bfs，今天想用dfs再实现一次，于是就出现了WA了。我的连续一次AC的记录就此作古。<br>也是好久不写DFS了，哪里该return都忘了。开始还担心会不会出现堆栈溢出的情况，后来估计DFS的层数也不高，也就AC了。<br>所以关于本题，有几个注意点：</p>
<blockquote>
<p>第一个就是，样例虽然是图像是连在一起的，但是测试数据不一定图像是连着的，也就是说，可能存在若干个连通图的情况，于是，要有个东西记录是否还有没有搜索过的点。<br>第二个就是，将一个点上色（黑或白）之后，要检查它和所有连接点是否冲突，尤其是对最后一个上色的点，不能一上了之（好邪恶- -），要记得验证，如果不对就得return false</p>
</blockquote>
<p>以下是我的DFS代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span> adjlist[<span class="number">10001</span>];</div><div class="line"><span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> unprobed;</div><div class="line"><span class="keyword">bool</span> dfs(<span class="keyword">int</span> *borw,<span class="keyword">int</span> cur)</div><div class="line">{</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span>::iterator it = adjlist[cur].begin(); it != adjlist[cur].end(); it++)</div><div class="line">	{</div><div class="line">		<span class="keyword">if</span> (borw[cur] == borw[it-&gt;first])</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span> (borw[it-&gt;first] == <span class="number">0</span>)</div><div class="line">		{</div><div class="line">			borw[it-&gt;first] = -borw[cur];</div><div class="line">			<span class="keyword">if</span> (!dfs(borw, it-&gt;first))</div><div class="line">			{</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			}</div><div class="line">			<span class="keyword">else</span>{</div><div class="line">				;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	unprobed.erase(unprobed.find(cur));</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; t;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> n, m;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line">		unprobed.clear();</div><div class="line">		<span class="keyword">int</span> *borw = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</div><div class="line">		{</div><div class="line">			adjlist[j].clear();</div><div class="line">			borw[j] = <span class="number">0</span>;</div><div class="line">			unprobed.insert(j);</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> u, v;</div><div class="line">			<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</div><div class="line">			adjlist[u][v] = <span class="number">1</span>;</div><div class="line">			adjlist[v][u] = <span class="number">1</span>;</div><div class="line">		}</div><div class="line">		<span class="keyword">bool</span> flag = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">while</span> (flag && (!unprobed.empty()))</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> u = *(unprobed.begin());</div><div class="line">			<span class="comment">//unprobed.erase(unprobed.begin());</span></div><div class="line">			borw[u] = <span class="number">1</span>;</div><div class="line">			flag = dfs(borw, u);</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (flag)</div><div class="line">		{</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Correct"</span> &lt;&lt; endl;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong"</span> &lt;&lt; endl;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以下是我BFS的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>&gt;</span> adjTab;</div><div class="line"><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> myQueue;</div><div class="line"><span class="stl_container"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;</span> unprobed;</div><div class="line"><span class="keyword">int</span> myColor[<span class="number">10001</span>];</div><div class="line"><span class="keyword">void</span> initialize(<span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</div><div class="line">	{</div><div class="line">		<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> tempVec;</div><div class="line">		adjTab.push_back(tempVec);</div><div class="line">		myColor[i] = <span class="number">0</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">		unprobed.insert(i);</div><div class="line">}</div><div class="line"><span class="keyword">void</span> construnctAdjTab(<span class="keyword">int</span> m)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> end1, end2;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">	{</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; end1 &gt;&gt; end2;</div><div class="line">		adjTab[end1].push_back(end2);</div><div class="line">		adjTab[end2].push_back(end1);</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">bool</span> BFS()</div><div class="line">{</div><div class="line">	<span class="keyword">while</span> (!myQueue.empty())</div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> u = *(myQueue.begin());</div><div class="line">		myQueue.erase(myQueue.begin());</div><div class="line">		<span class="comment">//if (myColor[u] == 0) myColor[u] = 1;</span></div><div class="line">		<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>::size_type i = <span class="number">0</span>; i &lt; adjTab[u].size(); i++)</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> v = adjTab[u][i];</div><div class="line">			<span class="keyword">if</span> (myColor[v] == myColor[u]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">if</span> (myColor[v] == <span class="number">0</span>)</div><div class="line">			{</div><div class="line">				myQueue.push_back(v);</div><div class="line">				unprobed.erase(unprobed.find(v));</div><div class="line">				myColor[v] = -myColor[u];</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; t;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</div><div class="line">	{</div><div class="line">		adjTab.clear();</div><div class="line">		myQueue.clear();</div><div class="line">		unprobed.clear();</div><div class="line">		<span class="keyword">int</span> n, m;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line">		initialize(n);</div><div class="line">		construnctAdjTab(m);</div><div class="line">		<span class="keyword">bool</span> flag = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">while</span> (flag && (!unprobed.empty()))</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> u = *(unprobed.begin());</div><div class="line">			unprobed.erase(unprobed.begin());</div><div class="line">			myColor[u] = <span class="number">1</span>;</div><div class="line">			myQueue.push_back(u);</div><div class="line">			flag=BFS();</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (flag)</div><div class="line">		{</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Correct"</span> &lt;&lt; endl;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong"</span> &lt;&lt; endl;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1121：二分图一•二分图判定">题目1121：二分图一•二分图判定</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>大家好，我是小Hi和小Ho的]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1128]]></title>
    <link href="http://youngyangyang.com/2015/04/14/hiho1128/"/>
    <id>http://youngyangyang.com/2015/04/14/hiho1128/</id>
    <published>2015-04-14T04:11:02.000Z</published>
    <updated>2015-04-14T04:12:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1128：二分·二分查找">题目1128：二分·二分查找</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>Nettle最近在玩《艦これ》，因此Nettle收集了很多很多的船(这里我们假设Nettle氪了很多金，开了无数个船位)。去除掉重复的船之后，还剩下N(1≤N≤1,000,000)种不同的船。每一艘船有一个稀有值，任意两艘船的稀有值都不相同，稀有值越小的船越稀有，价值也就越高。<br>Nettle现在通过大建又造出了一艘船，他想知道这艘船是不是重复的。如果是重复的，那么这艘船在Nettle所有的船里面稀有值排多少位。<br>问题一<br>Nettle已经先把自己所有船按照稀有值从小到大排列好了(a[1..N])，我们要做的是看看新得到的船(假设稀有值为K)是否在这个序列中，且有对应的a[i]=K时，i为多少？<br>问题二<br>因为Nettle的船太多了，他不愿意去给所有船按照稀有值排序，而是直接告诉了我们每一艘船的稀有值。在这种情况下我们该如何解决这个问题呢？<br><strong>输入</strong><br>第1行：2个整数N,k。N表示数组长度，K表示需要查找的数；<br>第2行：N个整数，表示a[1..N]，保证不会出现重复的数，1≤a[i]≤2,000,000,000。<br><strong>输出</strong><br>第1行：一个整数t，表示K在数组中是第t小的数，若K不在数组中，输出-1。<br><strong>样例输入</strong></p>
<blockquote>
<p>10 5180<br>2970 663 5480 4192 4949 1 1387 4428 5180 2761</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>9</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>连续两天一次AC的感觉真是太好了。<br>现在分析问题：</p>
<blockquote>
<p>问题一，其实是一个排好序之后的二分查找问题<br>问题二，其实是在一的基础上，用类似于快速排序的思想将数组分成三段，然后找出其中的一段继续进行二分查找</p>
</blockquote>
<p>trick和昨天是一样的</p>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> temp = shiparr[i];</div><div class="line">	shiparr[i] = shiparr[j];</div><div class="line">	shiparr[j] = temp;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> popsearch(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++)</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tail; j++)</div><div class="line">			<span class="keyword">if</span> (shiparr[i]&gt;shiparr[j])</div><div class="line">				swap(shiparr, i, j);</div><div class="line">	<span class="keyword">int</span> index = head;</div><div class="line">	<span class="keyword">while</span> (index &lt;= tail && shiparr[index] != k)</div><div class="line">		index++;</div><div class="line">	<span class="keyword">if</span> (index &lt;= tail) <span class="keyword">return</span> index;</div><div class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> bisearch(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">	<span class="keyword">if</span> (tail &lt;= head + <span class="number">5</span>) <span class="keyword">return</span> popsearch(shiparr, head, tail, k);</div><div class="line">	<span class="keyword">int</span> mid = (head + tail) / <span class="number">2</span>;</div><div class="line">	<span class="keyword">if</span> (shiparr[head] &gt; shiparr[mid]) swap(shiparr, head, mid);</div><div class="line">	<span class="keyword">if</span> (shiparr[head] &gt; shiparr[tail])swap(shiparr, head, tail);</div><div class="line">	<span class="keyword">if</span> (shiparr[mid] &gt; shiparr[tail]) swap(shiparr, mid, tail);</div><div class="line">	swap(shiparr, head, mid);</div><div class="line">	<span class="keyword">int</span> i = head + <span class="number">1</span>, j = tail - <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span> (i &lt; j)</div><div class="line">	{</div><div class="line">		<span class="keyword">while</span> (shiparr[j] &gt; shiparr[head]) j--;</div><div class="line">		<span class="keyword">while</span> (shiparr[i] &lt; shiparr[head]) i++;</div><div class="line">		<span class="keyword">if</span> (i &lt; j) swap(shiparr, i, j);</div><div class="line">	}</div><div class="line">	swap(shiparr, head, j);</div><div class="line">	<span class="keyword">if</span> (shiparr[j] == k) <span class="keyword">return</span> j;</div><div class="line">	<span class="keyword">if</span> (shiparr[j] &gt; k) <span class="keyword">return</span> bisearch(shiparr, head, j - <span class="number">1</span>, k);</div><div class="line">	<span class="keyword">return</span> bisearch(shiparr, j + <span class="number">1</span>, tail, k);</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n, k;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</div><div class="line">	<span class="keyword">int</span> *shiparr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">	shiparr[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; shiparr[i];</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; bisearch(shiparr, <span class="number">0</span>, n, k) &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1128：二分·二分查找">题目1128：二分·二分查找</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>Nettle最近在玩《艦これ》，因此Ne]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1133]]></title>
    <link href="http://youngyangyang.com/2015/04/13/hiho1133/"/>
    <id>http://youngyangyang.com/2015/04/13/hiho1133/</id>
    <published>2015-04-13T07:21:41.000Z</published>
    <updated>2015-04-13T07:23:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1133：二分·二分查找之k小数">题目1133：二分·二分查找之k小数</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回里我们知道Nettle在玩《艦これ》，Nettle的镇守府有很多船位，但船位再多也是有限的。Nettle通过捞船又出了一艘稀有的船，但是已有的N(1≤N≤1,000,000)个船位都已经有船了。所以Nettle不得不把其中一艘船拆掉来让位给新的船。Nettle思考了很久，决定随机选择一个k，然后拆掉稀有度第k小的船。 已知每一艘船都有自己的稀有度，Nettle现在把所有船的稀有度值告诉你，希望你能帮他找出目标船。<br><strong>输入</strong><br>第1行：2个整数N,k。N表示数组长度，<br>第2行：N个整数，表示a[1..N]，保证不会出现重复的数，1≤a[i]≤2,000,000,000。<br><strong>输出</strong><br>第1行：一个整数t，表示t在数组中是第k小的数，若K不在数组中，输出-1。<br><strong>样例输入</strong></p>
<blockquote>
<p>10 4<br>1732 4176 2602 6176 1303 6207 3125 1 1011 6600</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>1732</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>这道题应该可以用两种方法来做：</p>
<blockquote>
<p>第一种是堆排序，先将前k个数构建成一个最大堆，然后每次读入一个新的数就进行上滤，直到读完，最后将堆顶的数输出，这就是第k小的数了。<br>第二种是二分查找，思想是采用类似于快速排序的方法，将数组分为三段，第一段为小于a的数，第二段为a，第三段为大于d的数，那么如果a是第k小的数，就输出，如果不是就在两侧找。</p>
</blockquote>
<p>我在这道题里用了几个trick:</p>
<blockquote>
<p>1、添加一个0项，因为要排序的数都大于0，所以可以用0来填补数组[0]的位置，减少逻辑上的问题<br>2、为了避免二分查找退化，我在找标志数的时候，是比较head，mid，tail处三个数的大小，然后将中间一个放在首位，最小的放在mid位，最大的放在tail位。这也可以实现一个防止数组越界的问题。<br>3、如果tail和head相差太小（我设为5），那么做二分的意义也就不大了，我直接做了一个冒泡排序，会更简单一点。</p>
</blockquote>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> temp = shiparr[left];</div><div class="line">	shiparr[left] = shiparr[right];</div><div class="line">	shiparr[right] = temp;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> popsort(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++)</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tail; j++)</div><div class="line">			<span class="keyword">if</span> (shiparr[i]&gt;shiparr[j])</div><div class="line">				swap(shiparr, i, j);</div><div class="line">	<span class="keyword">return</span> shiparr[k];</div><div class="line">}</div><div class="line"><span class="keyword">int</span> bisearch(<span class="keyword">int</span> *shiparr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail,<span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">	<span class="keyword">if</span> (head + <span class="number">5</span> &gt;= tail)</div><div class="line">		<span class="keyword">return</span> popsort(shiparr, head, tail, k);</div><div class="line">	<span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;</div><div class="line">	<span class="keyword">if</span> (shiparr[head] &gt; shiparr[mid]) swap(shiparr, head, mid);</div><div class="line">	<span class="keyword">if</span> (shiparr[head] &gt; shiparr[tail])swap(shiparr, head, tail);</div><div class="line">	<span class="keyword">if</span> (shiparr[mid] &gt; shiparr[tail])swap(shiparr, mid, tail);</div><div class="line">	swap(shiparr, head, mid);</div><div class="line">	<span class="keyword">int</span> i = head + <span class="number">1</span>, j = tail - <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span> (i &lt; j)</div><div class="line">	{</div><div class="line">		<span class="keyword">while</span> (shiparr[j] &gt; shiparr[head]) j--;</div><div class="line">		<span class="keyword">while</span> (shiparr[i] &lt; shiparr[head]) i++;</div><div class="line">		<span class="keyword">if</span> (i &lt; j) swap(shiparr, i, j);<span class="comment">//好像以前这个题目wa的时候就是因为没写这句话</span></div><div class="line">	}</div><div class="line">	swap(shiparr, head, j);</div><div class="line">	<span class="keyword">if</span> (k == j) <span class="keyword">return</span> shiparr[j];</div><div class="line">	<span class="keyword">if</span> (k &lt; j)<span class="keyword">return</span> bisearch(shiparr, head, j - <span class="number">1</span>, k);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> bisearch(shiparr, j + <span class="number">1</span>, tail, k);</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n, k;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</div><div class="line">	<span class="keyword">int</span> *shiparr=<span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">	shiparr[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; shiparr[i];</div><div class="line">	<span class="keyword">if</span> (k &gt; n || k &lt; <span class="number">1</span>) </div><div class="line">	{</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; -<span class="number">1</span> &lt;&lt; endl;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	}</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; bisearch(shiparr, <span class="number">0</span>, n,k) &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1133：二分·二分查找之k小数">题目1133：二分·二分查找之k小数</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回里我们知道Net]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1143]]></title>
    <link href="http://youngyangyang.com/2015/04/12/hiho1143/"/>
    <id>http://youngyangyang.com/2015/04/12/hiho1143/</id>
    <published>2015-04-12T14:56:27.000Z</published>
    <updated>2015-04-12T14:59:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1143：骨牌覆盖问题·一">题目1143：骨牌覆盖问题·一</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：<br>我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？<br> 举个例子，对于长度为1到3的棋盘，我们有下面几种覆盖方式：<br> <img src="http://media.hihocoder.com/problem_images/20150411/1428731713269.png" style="width:50%;" title="week41_1.PNG"><br><strong>输入</strong><br>第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000<br><strong>输出</strong><br>第1行：1个整数，表示覆盖方案数 MOD 19999997<br><strong>样例输入</strong></p>
<blockquote>
<p>62247088</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>17748018</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>画图可以知道这就是一个斐波那契数列，递推公式一致f(n)=f(n-1)+f(n-2)。<br>提示里面有关矩阵相乘的化简方法非常棒：将n转换成2进制，然后再求响应的乘积就行了，这和我们算标量的幂的化简方法是一样的。<br>因为要mod19999997，所以最大可能为19999996，而19999996^2超过int型了，所以要用long或者long long型。</p>
<blockquote>
<p>可以考虑特征向量和特征根的方法来求，我觉得也很简单，毕竟特征根和特征向量存在的意义之一就是求解矩阵的n次幂和某个向量成乘积。就是最后的结果应该是取最近的整数，毕竟是某个无理数的幂。</p>
</blockquote>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">void</span> oct2bi(<span class="keyword">int</span> n, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &bivec)</div><div class="line">{</div><div class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>)</div><div class="line">	{</div><div class="line">		bivec.push_back(n % <span class="number">2</span>);</div><div class="line">		n /= <span class="number">2</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">	<span class="comment">//n = 62247088;</span></div><div class="line">	<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> bivec;</div><div class="line">	oct2bi(n, bivec);</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mi[<span class="number">100</span>][<span class="number">4</span>];</div><div class="line">	mi[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; mi[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">	mi[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>; mi[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">	{</div><div class="line">		mi[i][<span class="number">0</span>] = (mi[i - <span class="number">1</span>][<span class="number">0</span>] * mi[i - <span class="number">1</span>][<span class="number">0</span>] + mi[i - <span class="number">1</span>][<span class="number">1</span>] * mi[i - <span class="number">1</span>][<span class="number">2</span>]) % <span class="number">19999997</span>;</div><div class="line">		mi[i][<span class="number">1</span>] = ((mi[i - <span class="number">1</span>][<span class="number">0</span>] + mi[i - <span class="number">1</span>][<span class="number">3</span>])*mi[i - <span class="number">1</span>][<span class="number">1</span>]) % <span class="number">19999997</span>;</div><div class="line">		mi[i][<span class="number">2</span>] = ((mi[i - <span class="number">1</span>][<span class="number">0</span>] + mi[i - <span class="number">1</span>][<span class="number">3</span>])*mi[i - <span class="number">1</span>][<span class="number">2</span>]) % <span class="number">19999997</span>;</div><div class="line">		mi[i][<span class="number">3</span>] = (mi[i - <span class="number">1</span>][<span class="number">1</span>] * mi[i - <span class="number">1</span>][<span class="number">2</span>] + mi[i - <span class="number">1</span>][<span class="number">3</span>] * mi[i - <span class="number">1</span>][<span class="number">3</span>]) % <span class="number">19999997</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">int</span> ans[<span class="number">4</span>];</div><div class="line">	ans[<span class="number">0</span>] = <span class="number">1</span>; ans[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">	ans[<span class="number">2</span>] = <span class="number">0</span>; ans[<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = bivec.size()-<span class="number">1</span>; i &gt;=<span class="number">0</span>;i--)</div><div class="line">		<span class="keyword">if</span> (bivec[i] == <span class="number">1</span>)</div><div class="line">		{</div><div class="line">			<span class="keyword">long</span> <span class="keyword">long</span> temp[<span class="number">4</span>];</div><div class="line">			temp[<span class="number">0</span>] = (ans[<span class="number">0</span>] * mi[i][<span class="number">0</span>] + ans[<span class="number">1</span>] * mi[i][<span class="number">2</span>]) % <span class="number">19999997</span>;</div><div class="line">			temp[<span class="number">1</span>] = (ans[<span class="number">0</span>] * mi[i][<span class="number">1</span>] + ans[<span class="number">1</span>] * mi[i][<span class="number">3</span>]) % <span class="number">19999997</span>;</div><div class="line">			temp[<span class="number">2</span>] = (ans[<span class="number">2</span>] * mi[i][<span class="number">0</span>] + ans[<span class="number">3</span>] * mi[i][<span class="number">2</span>]) % <span class="number">19999997</span>;</div><div class="line">			temp[<span class="number">3</span>] = (ans[<span class="number">2</span>] * mi[i][<span class="number">1</span>] + ans[<span class="number">3</span>] * mi[i][<span class="number">3</span>]) % <span class="number">19999997</span>;;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</div><div class="line">				ans[j] = temp[j];</div><div class="line">		}</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; ans[<span class="number">3</span>] &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1143：骨牌覆盖问题·一">题目1143：骨牌覆盖问题·一</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>骨牌，一种古老的玩具。今天我们要研究]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1139]]></title>
    <link href="http://youngyangyang.com/2015/04/10/hiho1139/"/>
    <id>http://youngyangyang.com/2015/04/10/hiho1139/</id>
    <published>2015-04-10T13:34:33.000Z</published>
    <updated>2015-04-14T04:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1139：二分-二分答案">题目1139：二分.二分答案</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回和上上回里我们知道Nettle在玩《艦これ》，Nettle在整理好舰队之后终于准备出海捞船和敌军交战了。<br>在这个游戏里面，海域是N个战略点(编号1..N)组成，如下图所示<br><img src="http://media.hihocoder.com/problem_images/20150321/14269264041008.png" style="width:100%;" title="map.png"><br>其中红色的点表示有敌人驻扎，猫头像的的点表示该地图敌军主力舰队(boss)的驻扎点，虚线表示各个战略点之间的航线(无向边)。<br>在游戏中要从一个战略点到相邻战略点需要满足一定的条件，即需要舰队的索敌值大于等于这两点之间航线的索敌值需求。<br>由于提高索敌值需要将攻击机、轰炸机换成侦察机，舰队索敌值越高，也就意味着舰队的战力越低。<br>另外在每一个战略点会发生一次战斗，需要消耗1/K的燃料和子弹。必须在燃料和子弹未用完的情况下进入boss点才能与boss进行战斗，所以舰队最多只能走过K条航路。<br>现在Nettle想要以最高的战力来进攻boss点，所以他希望能够找出一条从起始点(编号为1的点)到boss点的航路，使得舰队需要达到的索敌值最低，并且有剩余的燃料和子弹。</p>
<p>特别说明：两个战略点之间可能不止一条航线，两个相邻战略点之间可能不止一条航线。保证至少存在一条路径能在燃料子弹用完前到达boss点。<br><strong>输入</strong><br>第1行：4个整数N,M,K,T。N表示战略点数量，M表示航线数量，K表示最多能经过的航路，T表示boss点编号, 1≤N,K≤10,000, N≤M≤100,000<br>第2..M+1行：3个整数u,v,w，表示战略点u,v之间存在航路，w表示该航路需求的索敌值，1≤w≤1,000,000。<br><strong>输出</strong><br>第1行：一个整数，表示舰队需要的最小索敌值。<br><strong>样例输入</strong></p>
<blockquote>
<p>5 6 2 5<br>1 2 3<br>1 3 2<br>1 4 4<br>2 5 2<br>3 5 5<br>4 5 3<br><strong>样例输出</strong><br>3</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>本题的提示还是比较奇葩的= =因为我觉得如果这么做，不就是做若干次搜索么，不如完整做一次搜索岂不是更好？<br>所以就考虑了直接上搜索了，而如果用深搜的话，因为k最大可以取10000，我担心栈会溢出，所以还是采用了宽搜的方法。<br>但还是调了一天，出错原因找到了，在我的代码里也标注出来了。<br>出错情况在于，如果有若干个点可以到达同一个点，且宽搜里面排在后面到达的值比较小的话，如果不加这句话会出错。<br>出错原因。。。我还要想想，妈蛋怎么想都不用加的啊。<br>最后有两个tip：</p>
<blockquote>
<p>以后宽搜不用自己写队列了，用stl给的queue就行了<br>以前存储邻接矩阵用的是vector<vector<int>&gt;，今天发现用map更简单</vector<int></p>
</blockquote>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">include &lt;iostream&gt;</div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span> mymap[<span class="number">10001</span>];</div><div class="line"><span class="keyword">struct</span> node{</div><div class="line">	<span class="keyword">int</span> a,cost,k;<span class="comment">//a表示现在在哪个点，k表示宽搜到了第几层</span></div><div class="line">	node(<span class="keyword">int</span> _a,<span class="keyword">int</span> _cost, <span class="keyword">int</span> _k) :a(_a),cost(_cost), k(_k){}</div><div class="line">};</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n, m, k, t;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> maxweight = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,u,v,w; i &lt; m; i++)</div><div class="line">	{</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</div><div class="line">		<span class="keyword">if</span> (w&gt;maxweight) maxweight = w;</div><div class="line">		<span class="keyword">if</span> (mymap[u][v] == <span class="number">0</span> || mymap[u][v]&gt;w)</div><div class="line">			mymap[u][v] = w;</div><div class="line">		mymap[v][u] = mymap[u][v];</div><div class="line">	}</div><div class="line">	<span class="keyword">int</span> *pointweight = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">	pointweight[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//因为权值最大也不会超过maxweight，所以我将到达每个点所需要的权值设为max</span></div><div class="line">		pointweight[i] = maxweight;</div><div class="line">	<span class="stl_container"><span class="built_in">queue</span>&lt;node&gt;</span> myque;</div><div class="line">	myque.push(node(<span class="number">1</span>, <span class="number">0</span>,<span class="number">0</span>));</div><div class="line">	<span class="keyword">while</span> (!myque.empty())</div><div class="line">	{</div><div class="line">		node cur = myque.front();</div><div class="line">		myque.pop();</div><div class="line">		<span class="keyword">if</span> (pointweight[cur.a] &lt; cur.cost)<span class="comment">//原来没有加这句话，出错</span></div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">if</span> (cur.k == k)<span class="comment">//如果已经走满k条边，那么结束</span></div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span>::iterator it = mymap[cur.a].begin(); it != mymap[cur.a].end(); it++)</div><div class="line">		{</div><div class="line">			<span class="keyword">int</span> nowmax = (pointweight[cur.a] &gt; it-&gt;second ? pointweight[cur.a] : it-&gt;second);<span class="comment">//找从a到it-&gt;first点所需要的权值，为到点a和点a到it-&gt;first点路程中最大的那个</span></div><div class="line">			<span class="keyword">if</span> (pointweight[it-&gt;first] &gt; nowmax)<span class="comment">//如果到it-&gt;first能比现在的小，那么就更新</span></div><div class="line">			{</div><div class="line">				pointweight[it-&gt;first] = nowmax;</div><div class="line">				myque.push(node(it-&gt;first,nowmax, cur.k + <span class="number">1</span>));</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; pointweight[t] &lt;&lt; endl;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1139：二分-二分答案">题目1139：二分.二分答案</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回和上上回里我们知道Nettle在]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1141]]></title>
    <link href="http://youngyangyang.com/2015/04/09/hiho1141/"/>
    <id>http://youngyangyang.com/2015/04/09/hiho1141/</id>
    <published>2015-04-09T06:31:49.000Z</published>
    <updated>2015-04-14T04:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1141：二分-归并排序之逆序对">题目1141：二分.归并排序之逆序对</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回、上上回以及上上上回里我们知道Nettle在玩《艦これ》。经过了一番苦战之后，Nettle又获得了的很多很多的船。<br>这一天Nettle在检查自己的舰队列表：<br><img src="http://media.hihocoder.com/problem_images/20150328/14275388536115.png" title="list.png" style="width:70%;border:1px solid #ccc;padding:5px;margin:10px 0;"><br>我们可以看到，船默认排序是以等级为参数。但实际上一个船的火力值和等级的关系并不大，所以会存在A船比B船等级高，但是A船火力却低于B船这样的情况。比如上图中77级的飞龙改二火力就小于55级的夕立改二。<br>现在Nettle将按照等级高低的顺序给出所有船的火力值，请你计算出一共有多少对船满足上面提到的这种情况。<br><strong>输入</strong><br>第1行：1个整数N。N表示舰船数量, 1≤N≤100,000<br>第2行：N个整数，第i个数表示等级第i低的船的火力值a[i]，1≤a[i]≤2^31-1。<br><strong>输出</strong><br>第1行：一个整数，表示有多少对船满足“A船比B船等级高，但是A船火力低于B船”。<br><strong>样例输入</strong></p>
<blockquote>
<p>10<br>1559614248 709366232 500801802 128741032 1669935692 1993231896 369000208 381379206 962247088 237855491<br><strong>样例输出</strong><br>27</p>
</blockquote>
<h2 id="分析">分析</h2>
<p>本题的思想就是归并排序。什么时候我要写个类实现各种排序，分享一下。<br>归并排序实现一下就行了，然后再统计一下左半边比右半边大的数目，求个和。</p>
<blockquote>
<p>tip：输出的大小要是long long型，因为N最大可以取100,000，所以如果全部是逆序的话，那么就有1+2+……+99,999=自己算一下吧，应该是超过int型了。</p>
</blockquote>
<p>以下是我的代码</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span>  mergesort(<span class="keyword">long</span> <span class="keyword">long</span>  * a, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</div><div class="line">{</div><div class="line">	<span class="keyword">if</span> (head &gt;= tail) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> mid = (head + tail) / <span class="number">2</span>;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = mergesort(a, head, mid) + mergesort(a, mid + <span class="number">1</span>, tail);<span class="comment">//归并是一种递归，所以要先做完小的，再做大的。小的的范围一定要确定好。</span></div><div class="line">	<span class="keyword">int</span> templefthead = head, temprighthead = mid + <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> numberofb=<span class="number">0</span>;<span class="comment">//记录已经排序好了的后面数组中的个数，有点绕头，其实就是提示里面排好序的b数组中的元素个数</span></div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> *b = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[tail - head + <span class="number">1</span>];<span class="comment">//归并排序需要另外开辟空间</span></div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tempans = <span class="number">0</span>;<span class="comment">//统计本次归并总共找到的逆序对数</span></div><div class="line">	<span class="keyword">while</span> (templefthead &lt;= mid && temprighthead &lt;= tail)</div><div class="line">	{</div><div class="line">		<span class="keyword">if</span> (a[templefthead] &lt;= a[temprighthead])</div><div class="line">		{</div><div class="line">			b[index++] = a[templefthead++];</div><div class="line">			tempans += numberofb;</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span></div><div class="line">		{</div><div class="line">			b[index++] = a[temprighthead++];</div><div class="line">			numberofb++;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> (templefthead &gt; mid)</div><div class="line">	{</div><div class="line">		<span class="keyword">while</span> (temprighthead &lt;= tail)</div><div class="line">			b[index++] = a[temprighthead++];</div><div class="line">	}</div><div class="line">	<span class="keyword">else</span>{</div><div class="line">		<span class="keyword">while</span> (templefthead &lt;= mid)</div><div class="line">		{</div><div class="line">			b[index++] = a[templefthead++];</div><div class="line">			tempans += numberofb;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	index = <span class="number">0</span>;</div><div class="line">	templefthead = head;</div><div class="line">	<span class="keyword">while</span> (templefthead &lt;= tail)</div><div class="line">		a[templefthead++] = b[index++];</div><div class="line">	<span class="keyword">return</span> (ans + tempans);</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> *a = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>)&lt;&lt;endl;</div><div class="line">	<span class="comment">/*for (int i = 0; i &lt; n; i++)</span></div><div class="line">		cout &lt;&lt; a[i] &lt;&lt; endl;*/</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1141：二分-归并排序之逆序对">题目1141：二分.归并排序之逆序对</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>在上一回、上上回以及上上]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1142]]></title>
    <link href="http://youngyangyang.com/2015/04/08/hiho1142/"/>
    <id>http://youngyangyang.com/2015/04/08/hiho1142/</id>
    <published>2015-04-08T07:20:08.000Z</published>
    <updated>2015-04-08T07:25:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目1142：三分-三分求极值">题目1142：三分.三分求极值</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>这一次我们就简单一点了，题目在此：<br><img src="http://media.hihocoder.com/problem_images/20150404/14281364249436.png" style="width:70%;" title="week40_1.PNG"><br>在直角坐标系中有一条抛物线y=ax^2+bx+c和一个点P(x,y)，求点P到抛物线的最短距离d。<br><strong>输入</strong><br>第1行：5个整数a,b,c,x,y。前三个数构成抛物线的参数，后两个数x,y表示P点坐标。-200≤a,b,c,x,y≤200<br><strong>输出</strong><br>第1行：1个实数d，保留3位小数(四舍五入)<br><strong>样例输入</strong></p>
<blockquote>
<p>2 8 2 -2 6<br><strong>样例输出</strong><br>2.437</p>
</blockquote>
<h2 id="分析"><strong>分析</strong></h2>
<p>我刚开始没看提示，考虑做法：假设固定点p为（x1，y1）。在抛物线上有一点q（x0，y0）在任意移动。其中满足<br> $$ y0=ax^2+bx+c<br>则我只要考虑曲线在点（x0，y0）处的切线的方向向量和向量pq的夹角是不是为90°即可。而这应该是一个只有一个0点的函数。<br>但是后来发现有问题，假设a&gt;0，这只满足点p在曲线下方区域的情况，如果点p在曲线上方，就不可以这么做了。<br>当然不是不可以做，只是需要判断，所以我就没这么做下去。而是采用了提示中的方法。<br>pq的距离函数是一个关于x0的凸函数（至于为什么是凸函数，对于一元函数来说，就是二阶导数恒大于等于0）。<br>那么采用三分法就可以解决这个问题了。这个问题的解决有两个trick：</p>
<blockquote>
<p>第一是a==0的情况，需要单独考虑，这个时候就是点到直线的距离，直接用公式就可以了<br>第二是不管是三分还是二分法都需要初始的范围，那么我的方法就是找到两个点x1和x2，使得对于其中点mid=（x1+x2）/2.<br>有f(x1)&gt;f(mid)且f(x2)&gt;f(mid)。作为初始的范围。</p>
</blockquote>
<h2 id="以下是我的代码"><strong>以下是我的代码</strong></h2>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;<span class="comment">//g++里sqrt需要include这个头文件</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;<span class="comment">//格式化输出需要include这个头文件</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">double</span> distances(<span class="keyword">const</span> <span class="keyword">double</span> a, <span class="keyword">const</span> <span class="keyword">double</span> b, <span class="keyword">const</span> <span class="keyword">double</span> c, <span class="keyword">const</span> <span class="keyword">double</span> x, <span class="keyword">const</span> <span class="keyword">double</span> y, <span class="keyword">double</span> xx)</div><div class="line">{</div><div class="line">	<span class="keyword">double</span> temp[<span class="number">5</span>];</div><div class="line">	temp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">		temp[i] = temp[i - <span class="number">1</span>] * xx;</div><div class="line">	<span class="keyword">return</span> (a*a*temp[<span class="number">4</span>] + <span class="number">2</span> * a*b*temp[<span class="number">3</span>] + (<span class="number">1</span> + b*b + <span class="number">2</span> * a*c - <span class="number">2</span> * y*a)*temp[<span class="number">2</span>] + (-<span class="number">2</span> * x + <span class="number">2</span> * b*c - <span class="number">2</span> * b*y)*xx + x*x + c*c + y*y - <span class="number">2</span> * c*y);</div><div class="line">}</div><div class="line"><span class="keyword">double</span> tri(<span class="keyword">const</span> <span class="keyword">double</span> a,<span class="keyword">const</span> <span class="keyword">double</span> b,<span class="keyword">const</span> <span class="keyword">double</span> c,<span class="keyword">const</span> <span class="keyword">double</span> x,<span class="keyword">const</span> <span class="keyword">double</span> y,<span class="keyword">double</span> x1, <span class="keyword">double</span> x2)</div><div class="line">{</div><div class="line">	<span class="keyword">double</span> len = x2 - x1;</div><div class="line">	<span class="keyword">double</span> lm = x1 + len / <span class="number">3</span>;</div><div class="line">	<span class="keyword">double</span> rm = x2 - len / <span class="number">3</span>;</div><div class="line">	<span class="keyword">if</span> (rm - lm &lt; <span class="number">0.001</span>) <span class="keyword">return</span> (rm + lm) / <span class="number">2</span>;</div><div class="line">	<span class="keyword">double</span> dlm = distances(a, b, c, x, y, lm);</div><div class="line">	<span class="keyword">double</span> rlm = distances(a, b, c, x, y, rm);</div><div class="line">	<span class="keyword">if</span> (dlm == rlm) <span class="keyword">return</span> tri(a, b, c, x, y, lm, rm);</div><div class="line">	<span class="keyword">if</span> (dlm &lt; rlm) <span class="keyword">return</span> tri(a, b, c, x, y, x1, rm);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> tri(a, b, c, x, y, lm, x2);</div><div class="line">}</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> a, b, c, x, y;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y;</div><div class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>)</div><div class="line">	{</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(b*x - y + c) / <span class="built_in">sqrt</span>(b*b + c*c) &lt;&lt; endl;</div><div class="line">	}</div><div class="line">	<span class="keyword">else</span></div><div class="line">	{</div><div class="line">		<span class="keyword">double</span> x1 = x - <span class="number">10</span>, x2 = x + <span class="number">10</span>;</div><div class="line">		<span class="keyword">double</span> mid = x;</div><div class="line">		<span class="keyword">double</span> distancofmid = distances(a, b, c, x, y, mid);</div><div class="line">		<span class="keyword">while</span> (!(distances(a, b, c, x, y, x1) &gt; distancofmid && distances(a, b, c, x, y, x2) &gt; distancofmid))</div><div class="line">		{</div><div class="line">			x1 -= <span class="number">10</span>;</div><div class="line">			x2 += <span class="number">10</span>;</div><div class="line">		}</div><div class="line">		<span class="keyword">double</span> ansOfX = tri(a, b, c, x, y, x1, x2);</div><div class="line">		<span class="keyword">double</span> ansOfY = a*ansOfX*ansOfX + b*ansOfX + c;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt;setprecision(<span class="number">3</span>)&lt;&lt; <span class="built_in">sqrt</span>((ansOfX - x)*(ansOfX - x) + (ansOfY - y)*(ansOfY - y)) &lt;&lt; endl;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目1142：三分-三分求极值">题目1142：三分.三分求极值</h2>
<hr>
<p>时间限制:10000ms<br>单点时限:1000ms<br>内存限制:256MB<br><strong>描述</strong><br>这一次我们就简单一点了，题目在此：<]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在考试之后]]></title>
    <link href="http://youngyangyang.com/2015/04/03/afterexam/"/>
    <id>http://youngyangyang.com/2015/04/03/afterexam/</id>
    <published>2015-04-03T14:11:37.000Z</published>
    <updated>2015-04-03T14:18:50.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚考完了微软实习生的在线笔试，昨天做了阿里的在线笔试，最近又在做阿里的大数据竞赛。感觉真的忙不过来，不过从这段时间的经历来看，自己有很多事要做。</p>
<blockquote>
<p>-巩固计算机语言：从几次笔试的过程来看，自己虽然说是略懂某种程序语言，但实在不是精通。而且除了微软之外，其他的公司都同时考几种语言，看来过去那种一种语言打天下的日子已经一去不复返了。<br>-刷题。今天的微软在线笔试就是很好的例子，从读题到写出程序只要二十分钟，但调试到AC却要一个小时，这说明题量不够，还需要刷题。<br>-还有自己一直要学的机器学习方面的知识还要巩固。一本书都没读完，的确进度太慢。要抓紧。</p>
</blockquote>
<p>三月结束了实习，总算给自己一个自由身。自己也要抓紧机会弥补。四月时间并不长，要有紧迫感。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚考完了微软实习生的在线笔试，昨天做了阿里的在线笔试，最近又在做阿里的大数据竞赛。感觉真的忙不过来，不过从这段时间的经历来看，自己有很多事要做。</p>
<blockquote>
<p>-巩固计算机语言：从几次笔试的过程来看，自己虽然说是略懂某种程序语言，但实在不是精通。]]>
    </summary>
    
      <category term="生活记录" scheme="http://youngyangyang.com/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
      <category term="生活点滴" scheme="http://youngyangyang.com/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的书籍]]></title>
    <link href="http://youngyangyang.com/2015/03/31/booklist/"/>
    <id>http://youngyangyang.com/2015/03/31/booklist/</id>
    <published>2015-03-31T12:01:20.000Z</published>
    <updated>2015-03-31T12:12:11.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>最近在读：</p>
<p>《统计学习方法》 李航</p>
</blockquote>
<hr>
<blockquote>
<p>读过：</p>
<p>《C++ Primer》Stanley B.Lippman    Josee Lajoie     Barbara E.Moo</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>最近在读：</p>
<p>《统计学习方法》 李航</p>
</blockquote>
<hr>
<blockquote>
<p>读过：</p>
<p>《C++ Primer》Stanley B.Lippman    Josee Lajoie    ]]>
    </summary>
    
      <category term="books" scheme="http://youngyangyang.com/tags/books/"/>
    
      <category term="booklist" scheme="http://youngyangyang.com/categories/booklist/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hiho1000]]></title>
    <link href="http://youngyangyang.com/2015/01/30/hiho1000/"/>
    <id>http://youngyangyang.com/2015/01/30/hiho1000/</id>
    <published>2015-01-30T06:10:20.000Z</published>
    <updated>2015-03-27T02:50:39.000Z</updated>
    <content type="html"><![CDATA[<p>题目名称：A+B</p>
<p>时间限制:1000ms<br>单点时限:1000ms<br>内存限制:256MB</p>
<p>描述</p>
<p>求两个整数A+B的和</p>
<p>输入</p>
<p>输入包含多组数据。<br>每组数据包含两个整数A(1 ≤ A ≤ 100)和B(1 ≤ A ≤ 100)。</p>
<p>输出</p>
<p>对于每组数据输出A+B的和。</p>
<p>样例输入</p>
<blockquote>
<p>1 2<br>3 4</p>
</blockquote>
<p>样例输出</p>
<blockquote>
<p>3<br>7</p>
</blockquote>
<p>我的分析</p>
<blockquote>
<p>这道题很简单啦，就是给大家学会怎么使用这个OnlineJudge平台的练手题目而已。基本的C++语法没有问题就OK啦。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)){</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;(a+b)&lt;&lt;endl;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>题目名称：A+B</p>
<p>时间限制:1000ms<br>单点时限:1000ms<br>内存限制:256MB</p>
<p>描述</p>
<p>求两个整数A+B的和</p>
<p>输入</p>
<p>输入包含多组数据。<br>每组数据包含两个整数A(1 ≤ A ≤ 10]]>
    </summary>
    
      <category term="hihocoder" scheme="http://youngyangyang.com/tags/hihocoder/"/>
    
      <category term="一起刷hihocoder" scheme="http://youngyangyang.com/categories/%E4%B8%80%E8%B5%B7%E5%88%B7hihocoder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <link href="http://youngyangyang.com/2014/12/30/my-new-post/"/>
    <id>http://youngyangyang.com/2014/12/30/my-new-post/</id>
    <published>2014-12-30T10:42:20.000Z</published>
    <updated>2015-01-07T12:45:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="这是我的第一篇文章">这是我的第一篇文章</h1>
<p>markdown的语法怎么这么别扭，看起来一点都不舒服</p>
<h2 id="要不来总结一下2014年吧">要不来总结一下2014年吧</h2>
<h3 id="我才没那么无聊呢">我才没那么无聊呢</h3>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="这是我的第一篇文章">这是我的第一篇文章</h1>
<p>markdown的语法怎么这么别扭，看起来一点都不舒服</p>
<h2 id="要不来总结一下2014年吧">要不来总结一下2014年吧</h2>
<h3 id="我才没那么无聊呢">我才没那么无聊呢</h]]>
    </summary>
    
      <category term="生活记录" scheme="http://youngyangyang.com/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
      <category term="blog" scheme="http://youngyangyang.com/categories/blog/"/>
    
  </entry>
  
</feed>
